use graphql_client::*;
use regex::Regex;

use crate::{data::api::AnimeApi, services::files::ShowDetails};
use async_trait::async_trait;

#[derive(GraphQLQuery)]
#[graphql(
    schema_path = "src/data/anilist/schema.graphql",
    query_path = "src/data/anilist/fetch.graphql",
    response_derives = "Debug"
)]
struct FetchAnime;

#[derive(GraphQLQuery)]
#[graphql(
    schema_path = "src/data/anilist/schema.graphql",
    query_path = "src/data/anilist/search.graphql",
    response_derives = "Debug"
)]
struct SearchAnime;

struct Anilist;

#[async_trait]
impl AnimeApi for Anilist {
    /// Get the AniList ID of an anime by providing the name of the anime
    async fn search_anime(name: &str) -> anyhow::Result<i32> {
        // Build the GraphQL body that is needed to send to anilist
        // The name of the anime is the only variable that needs to be provided
        let body = SearchAnime::build_query(search_anime::Variables {
            name: name.to_string(),
        });

        let client = reqwest::Client::new();
        let response = client
            .post("https://graphql.anilist.co/")
            .json(&body)
            .send()
            .await?;

        // Automatically serialize the response into the ResponseData type
        // This is an autogenerated type by the GraphQL Library
        let anime = response
            .json::<search_anime::ResponseData>()
            .await?
            .media
            .ok_or(anyhow!("No Anime Found"))?;

        // TODO: The typecasting here is unfortunuate. For now, we know this is safe because Int in the
        // graphql is limited to 32 bit. This should no longer be needed once this issue:
        // https://github.com/graphql-rust/graphql-client/issues/266 is fixed.
        Ok(anime.id as i32)
    }

    /// Fetch anime details
    /// Parameters provided:
    /// anime_id: The AniList ID of the anime
    /// show: A mutable reference to the ShowDetails object
    ///
    /// This function uses the mutable reference to make an in-place modificaion to the following
    /// files:
    /// - name
    /// - description
    /// - banner image
    /// - cover image
    /// - episode name
    /// - episode thumbnail
    async fn fetch_anime(anime_id: i32, show: &mut ShowDetails) -> anyhow::Result<()> {
        // TODO: Remove this typecasting once this issue:
        // https://github.com/graphql-rust/graphql-client/issues/266 is fixed
        let request_body = FetchAnime::build_query(fetch_anime::Variables {
            id: anime_id as i64,
        });

        let client = reqwest::Client::new();
        let response = client
            .post("https://graphql.anilist.co/")
            .json(&request_body)
            .send()
            .await?;

        let response_body = response
            .json::<fetch_anime::ResponseData>()
            .await?
            .media
            .ok_or(anyhow!("Unable to find anime"))?;

        // If the response has a title, we need to get any of the english, romanji and native title in
        // that order. If none of the names are provided, we don't make any change
        if let Some(title) = response_body.title {
            if let Some(english) = title.english {
                show.name = english;
            } else if let Some(romaji) = title.romaji {
                show.name = romaji;
            } else if let Some(native) = title.native {
                show.name = native;
            }
        }

        show.description = response_body.description;
        show.banner_image = response_body.banner_image;

        if let Some(cover) = response_body.cover_image {
            show.cover_image = cover.extra_large;
        }

        // TODO: This whole block is a bit unfortunate. Need to think of a better way to structure
        // this.
        if let Some(episode_list) = response_body.streaming_episodes {
            // Iterate over the episodes from the GraphQL Response
            for try_episode in episode_list {
                if let Some(episode) = try_episode {
                    // We need to check if the episode has a title since it is used for extracting the
                    // episode number.
                    if let Some(title) = episode.title {
                        // Use the following Regex pattern to extract the episode number out of the
                        // episode name.
                        let pattern = Regex::new(r".*Episode.(\d+).*").unwrap();
                        if let Some(episode_match) = pattern.captures(title.as_str()) {
                            // Parse the episode number string into an i32 number.
                            let episode_number = String::from(&episode_match[1]).parse::<i32>()?;

                            // We need to do this since we want to avoid moving episode inside the
                            // closure
                            let episode_thumbnail = episode.thumbnail;

                            // In place modify the hashmap values
                            show.episodes
                                .entry(episode_number)
                                .and_modify(|map_episode| {
                                    map_episode.name = title;
                                    map_episode.thumbnail = episode_thumbnail;
                                });
                        }
                    }
                }
            }
        }

        Ok(())
    }
}
